<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[静态代理、动态代理与CGLIB代理简介.md]]></title>
    <url>%2F2019%2F07%2F29%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8ECGLIB%E4%BB%A3%E7%90%86%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1. 何为代理 代理模式(Proxy Pattern)是一种非常实用的设计模式,它提供了一种对目标对象的代理访问,从而可以在代理层加入额外的逻辑,以实现某种特殊功能,比如Spring事物、日志、切面处理等都用到了大量的代理技术.Java代理模式主要分为三种方式: 静态代理、动态代理及CGLIB代理. 2. 静态代理 其实就是代码的静态注入,代码耦合度比较高,见以下事例 123456789101112131415161718192021222324252627282930313233343536interface Animal &#123; void name();&#125;class Dog implements Animal &#123; @Override public void name() &#123; System.out.println("I'm dog..."); &#125;&#125;class StaticProxy implements Animal &#123; private Animal proxied; // 被代理对象, 本例中为Dog对象 StaticProxy(Animal animal) &#123; this.proxied = animal; &#125; @Override public void name() &#123; System.out.println("代理前..."); proxied.name(); System.out.println("代理后..."); &#125;&#125;public class StaticProxyDemo &#123; private static void say(Animal animal) &#123; animal.name(); &#125; public static void main(String[] args) &#123; say(new StaticProxy(new Dog())); // 简单静态代理 &#125;&#125; 输出如下: 123代理前...I&apos;m dog...代理后... 我们可以看到,在执行proxied.name()的前后加入了我们自己的逻辑.但是静态代理有个问题, 就是实现时需要为每个被代理对象都创建一个代理类,这无疑是巨大的工作量. 3. JDK动态代理 相比于静态代理,动态代理能够在运行时根据被代理对象动态的创建出代理对象,省去了静态代理冗余的代码量,见以下事例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.lang.reflect.Proxy;interface Animal &#123; void name();&#125;class Dog implements Animal &#123; @Override public void name() &#123; System.out.println("I'm dog..."); &#125;&#125;class DynamicProxyFactory &#123; private Object proxied; // 被代理对象 DynamicProxyFactory(Object proxied) &#123; this.proxied = proxied; &#125; Object getProxyInstance() &#123; // newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) // loader: 被代理对象的类加载器 // interfaces: 被代理对象实现的所有父类接口 // handler: 处理策略, 实现InvocationHandler接口(此处用了lambda表达式), // invoke的三个参数分别为：动态生成的代理对象、方法、参数 return Proxy.newProxyInstance( proxied.getClass().getClassLoader(), proxied.getClass().getInterfaces(), (proxy, method, args) -&gt; &#123; System.out.println("代理前..."); // 代理对象将参数args传递给真实对象proxied Object result = method.invoke(proxied, args); System.out.println("代理后..."); return result; &#125; ); &#125;&#125;public class DynamicProxyDemo &#123; private static void say(Animal animal) &#123; animal.name(); &#125; public static void main(String[] args) &#123; Object proxyInstance = new DynamicProxyFactory(new Dog()).getProxyInstance(); Animal animal = (Animal) proxyInstance; say(animal); &#125;&#125; 可以看到, 输出结果与上面相同. 在实现静态代理和动态代理两种模式后,我们发现它们都存在一定的局限性, 也就是都只能为有父类接口的实现类进行代理,而不能为单纯的类代理.因此接下来,我们介绍CGLIB工具包. 4. CGLIB代理 CGLIB是一个高性能的代码生成包,可以在运行期扩展java类和实现java接口. 其底层是通过小而快的字节码处理框架ASM,来转换字节码并生成新的类.它可以弥补JDK动态代理对接口高度依赖的局限性,具体见以下事例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;class Dog &#123; void name() &#123; System.out.println("I'm dog..."); &#125;&#125;class CGLIBProxyFactory implements MethodInterceptor &#123; private Object proxied; CGLIBProxyFactory(Object proxied) &#123; this.proxied = proxied; &#125; Object getProxyInstance() &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(proxied.getClass()); // 父类 enhancer.setCallback(this); // 回调函数 return enhancer.create(); &#125; // obj: this, the enhanced object // method: 代理方法 // args: 代理方法的参数 // proxy: 生成的代理类 @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("代理前..."); Object result = method.invoke(proxied, args); System.out.println("代理后..."); return result; &#125;&#125;public class CGLIBProxyDemo &#123; public static void main(String[] args) &#123; CGLIBProxyFactory proxyFactory = new CGLIBProxyFactory(new Dog()); Dog proxyInstance = (Dog) proxyFactory.getProxyInstance(); proxyInstance.name(); &#125;&#125; 可以看到,CGLIB既解决了JDK动态代理的局限性, 而且实现又非常简单. 其在Spring框架中被大量使用. 总结 静态代理代码理解简单,但是需要为每个被代理类编写代理程序,较为繁杂 JDK动态代理功能强大,但是对被代理对象有要求-需要其实现某接口 CGLIB解决了JDK动态代理的局限性, 适用范围广,非常推荐.]]></content>
      <tags>
        <tag>代理</tag>
        <tag>动态代理</tag>
        <tag>CGLIB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式配置中心Apollo搭建简单教程]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83Apollo%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Apollo（阿波罗）是携程开源的分布式配置中心，主要用于解决多环境配置参数紊乱的问题，能够集中化管理不同应用环境、不同集群的相关配置参数。以下介绍单机器使用不同端口去模拟DEV、UAT、PRO三套环境的详细步骤。 这里简述一下主要流程： 先在github上下载ctripcorp/apollo的master分支代码 使用scripts/docker-quick-start/sql/目录下的apolloconfigdb.sql和apolloportaldb.sql脚本建立4个数据库，分别如下： Apollo-portal: apolloportaldb Apollo-config/admin: apolloconfigdb_dev, apolloconfigdb_uat, apolloconfigdb_pro 注意使用apolloconfigdb.sql建立数据库时，需要改下数据库名称，分别对应DEV，UAT，PRO环境 修改scripts/build.sh脚本，更改结果如下: 12345678910111213141516#!/bin/sh# apollo config db infoapollo_config_db_url=jdbc:mysql://localhost:3306/apolloconfigdb?characterEncoding=utf8apollo_config_db_username=rootapollo_config_db_password=root# apollo portal db infoapollo_portal_db_url=jdbc:mysql://localhost:3306/apolloportaldb?characterEncoding=utf8apollo_portal_db_username=rootapollo_portal_db_password=root# meta server url, different environments should have different meta server addressesdev_meta=http://localhost:8080uat_meta=http://localhost:8180pro_meta=http://localhost:8280 这里的apolloconfigdb名字暂时先这样写，之后打包结束后会进行更改。端口设置如下：portalService端口为8070；dev环境：configService端口为8080，adminService端口为8090；uat环境：configService端口为8180，adminService端口为8190；pro环境：configService端口为8280，adminService端口为8290。 修改数据库 将apolloportaldb数据库中的serverconfig表中的apollo.portal.envs的值改为dev,uat,pro，以逗号隔离 将apolloconfigdb_dev数据库的serverconfig表中的eureka.service.url的value改为http://localhost:8080/eureka/ 将apolloconfigdb_uat数据库的serverconfig表中的eureka.service.url的value改为http://localhost:8180/eureka/ 将apolloconfigdb_pro数据库的serverconfig表中的eureka.service.url的value改为http://localhost:8280/eureka/ 编译项目, 运行sh scripts/build.sh 将上一步apollo-portal/target, apollo-adminservice/target, apollo-configservice/target得到的zip包进行归类，目录结构可参考如下： 1234567891011121314151617181920212223242526deploy-apollo├── apollo-portal-1.5.0-SNAPSHOT-github│ ├── apollo-portal-1.5.0-SNAPSHOT-sources.jar│ ├── apollo-portal-1.5.0-SNAPSHOT.jar│ ├── apollo-portal.conf│ ├── apollo-portal.jar│ ├── config│ └── scripts├── apollo-portal-1.5.0-SNAPSHOT-github.zip├── dev│ ├── apollo-adminservice-1.5.0-SNAPSHOT-github│ ├── apollo-adminservice-1.5.0-SNAPSHOT-github.zip│ ├── apollo-configservice-1.5.0-SNAPSHOT-github│ └── apollo-configservice-1.5.0-SNAPSHOT-github.zip├── pro│ ├── apollo-adminservice-1.5.0-SNAPSHOT-github│ ├── apollo-adminservice-1.5.0-SNAPSHOT-github.zip│ ├── apollo-configservice-1.5.0-SNAPSHOT-github│ └── apollo-configservice-1.5.0-SNAPSHOT-github.zip├── start.sh├── stop.sh└── uat ├── apollo-adminservice-1.5.0-SNAPSHOT-github ├── apollo-adminservice-1.5.0-SNAPSHOT-github.zip ├── apollo-configservice-1.5.0-SNAPSHOT-github └── apollo-configservice-1.5.0-SNAPSHOT-github.zip 其中，start.sh和stop.sh脚本为自己的准备，稍后介绍。 修改dev目录下apollo-adminservice-1.5.0-SNAPSHOT-github/config/application-github.properties中的数据库，对应为apolloconfigdb_dev，修改apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/startup.sh下的端口，具体为SERVER_PORT=8090；apollo-configservice-1.5.0-SNAPSHOT-github/config/application-github.properties中的数据库，对应为apolloconfigdb_dev，修改apollo-configservice-1.5.0-SNAPSHOT-github/scripts/startup.sh下的端口，具体为SERVER_PORT=8080 uat,pro目录下的数据和端口分为作相似的修改(db_uat, 8180, 8190; db_pro, 8280, 8290) 运行sh start.sh和sh stop.sh基本进行项目的启动和关闭 12345678910111213141516171819# start.sh#!/bin/bash# 每个环境需要先启动configservice，后启动adminservice）echo "启动DEV环境apollo服务..."sh dev/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/startup.shsh dev/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/startup.shecho "启UAT环境apollo服务..."sh uat/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/startup.shsh uat/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/startup.shecho "启动PRO环境apollo服务..."sh pro/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/startup.shsh pro/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/startup.shecho "启动apollo的portal服务..."sh apollo-portal-1.5.0-SNAPSHOT-github/scripts/startup.sh 123456789101112131415161718# stop.sh#!/bin/bashecho "关闭DEV环境apollo服务..."sh dev/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shsh dev/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shecho "关闭UAT环境apollo服务..."sh uat/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shsh uat/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shecho "关闭PRO环境apollo服务..."sh pro/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shsh pro/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shecho "关闭apollo的portal服务..."sh apollo-portal-1.5.0-SNAPSHOT-github/scripts/shutdown.sh 访问apollo控制界面 启动服务后，访问localhost:8070，默认用户名为apollo，密码为admin 注意事项，写在最后 如果启动服务时，发现报错，根据错误提示查看/opt/logs目录下的日志]]></content>
      <tags>
        <tag>apollo</tag>
        <tag>配置中心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON基本操作]]></title>
    <url>%2F2019%2F05%2F13%2FJSON%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[本文记录一些日常工作中关于Jackson核心API的使用，包括JsonNode的创建及解析、与HashMap的转换、如何从String中构造JsonNode、以及ArrayNode中元素的去重等等 JSON的两种形式分为两种形式JsonArray和JsonObject，其内部可以相互循环嵌套 JsonArray: [{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: &quot;10&quot;}, {&quot;name&quot;: &quot;Jim&quot;, &quot;age&quot;: &quot;12&quot;}] 最外面为中括号[]，内部可以为多个JsonObject JsonObject: {&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;, &quot;hobbies&quot;: [&quot;basketball&quot;, &quot;tennis&quot;, &quot;football&quot;]} 最外面为大括号{}，内部为key-value形式，value依然可以嵌套array和object 创建ArrayNode及ObjectNode 创建ArrayNode 1private static final ArrayNode arrayNode = new ObjectMapper().createArrayNode(); 创建ObjectNode 1private static final ObjectNode objectNode = new ObjectMapper().createObjectNode(); 创建JsonNode(ArrayNode和ObjectNode的基类) 1private static final JsonNode jsonNode = new ObjectMapper().create...Node(); //向上转型 HashMap与JsonNode的转换 HashMap初始化 12map.put("name", "leon");map.put("age", "10"); 转换为JsonNode 12JsonNode jsonNode = new ObejctMapper().convertValue(map, JsonNode.class);实际结果形式为: &#123;"name": "leon", "age": "10"&#125; 实际转换结果是ObjectNode，而不是ArrayNode 如果要将其转换为如下形式：[{&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;}]，即ArrayNode形式，那么采用如下做法： 12ArrayNode arrayNode = new ObjectMapper().createArrayNode();arrayNode.add(jsonNode); // 将step-2中的结果添加到ArrayNode中 从String中构造JsonNode12345String jsonStr = "&#123;\n" + "\"name\": \"leon\",\n" + "\"age\": \"10\"\n" + "&#125;";JsonNode jsonNode = new ObjectMapper().readTree(jsonStr); // 注意异常处理 JsonNode的解析 ObjectNode的解析 12// 对于jsonStr, &#123;"name": "leon", "age": "10"&#125;objectNode.get("name"); // result: leon ArrayNode的解析 1234567// 对于jsonStr, [&#123;"name": "leon", "age": "10"&#125;]ArrayNode nodes = (ArrayNode)jsonNode;for (JsonNode node : nodes) &#123; node.get("name").asText(); node.get("age").asText();&#125;或者使用下标遍历 ArrayNode中元素的去重 考虑jsonStr: [{&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;}, {&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;}, {&quot;name&quot;: &quot;Jim&quot;, &quot;age&quot;: :11}] 将jsonStr转换为ArrayNode 12JsonNode jsonNode = new ObjectMapper().readTree(jsonStr);ArrayNode arrayNode = (ArrayNode) jsonNode; 将其中的value对转换为tuple，以Set方式存储 此代码用到了java tuples，java tuples - github 12345678910111213141516171819202122232425public static Set&lt;Pair&lt;String, String&gt;&gt; removeDuplicatedItems(JsonNode node) &#123; Set&lt;Pair&lt;String, String&gt;&gt; set = new LinkedHashSet&lt;&gt;(); if (!node.isArray()) &#123; return set; &#125; ArrayNode identity = (ArrayNode) node; for (JsonNode each : identity) &#123; if (!each.isObject()) &#123; continue; &#125; try &#123; String name = each.get("name").asText(); String age = each.get("age").asText(); if (StringUtils.isEmpty(name) || StringUtils.isEmpty(age)) &#123; continue; &#125; set.add(Pair.with(name, age)); &#125; catch (RuntimeException ex) &#123; // OK continue; &#125; &#125; return set; &#125; 实际上结果已经去重 对于去重后的结果进行处理，构造JsonNode(实际为ArrayNode) 123456789// pairs为去重后的数对ArrayNode result = Tools.globalMapper.createArrayNode();for (Pair&lt;String, String&gt; p : pairs) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("name", p.getValue0()); map.put("age", p.getValue1()); result.add(new ObjectMapper().convertValue(map, JsonNode.class));&#125;return result; 总结以上对于java中使用Jackson构造及解析json进行了简单介绍，当然如果你使用Groovy的话，那么它自带了Groovy.json库，使用new JsonSlurper().parseText(&quot;&quot;)、JsonOutput.toJson(&quot;&quot;)等可以很方便的构造及解析json。]]></content>
      <tags>
        <tag>json</tag>
        <tag>jackson</tag>
        <tag>jsonnode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grep命令初探]]></title>
    <url>%2F2019%2F05%2F02%2Fgrep%E5%91%BD%E4%BB%A4%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[什么是grep对于在线上服务器排查错误，学会分析log就变得异常重要，grep命令具有非常强大的文本过滤能力，是一个很好的日志过滤工具。 首先需要注意的是， grep命令是按行过滤日志的，格式为grep [options] pattern file，options支持像-A，-B，-e，-E，-f，-i，-n，-v，-r等，pattern支持常见的正则匹配，以下对其进行详细介绍。 grep参数解析 grep -A 显示目标行及之后(after)的n行，如果有多个匹配结果，则以--分割 以foo.txt为例 12345678910➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep 'java' foo.txtjava pythonjavascript 过滤foo.txt中含有&#39;java&#39;的所在行及其之后的2行数据 123456➜ grep -A 2 'java' foo.txtjava pythonC# bashgroovy--javascript grep -B 显示目标行及之前(before)的n行，如果有多个匹配结果，则以--分割 123456➜ grep -B 2 'java' foo.txtjava python--groovygo scalajavascript grep -i 匹配时不分大小写 12➜ grep -i 'c#' foo.txtC# bash grep -e 可以利用多个条件进行或匹配 123➜ grep -e 'go' -e 'bash' foo.txtC# bashgo scala grep -E 可以看作是grep -e的简单版，对多个条件进行或匹配，直接以|分隔 123➜ grep -E 'go|bash' foo.txtC# bashgo scala 如果要使用grep命令进行与操作，那么可以利用正则，以下匹配同时含有&#39;go&#39;和&#39;scala&#39;的行 12➜ grep 'go.*scala' foo.txtgo scala grep -f grep -f reg.txt foo.txt为以reg.txt定义的规则过滤foo.txt里的内容 1234567➜ cat reg.txtjavagr.*vy➜ grep -f reg.txt foo.txtjava pythongroovyjavascript grep -n 显示过滤行的行数 1234567891011➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep -f reg.txt -n foo.txt1:java python3:groovy5:javascript grep -v 显示未匹配到的行。以下显示未匹配到的行，并显示行号 123➜ grep -f reg.txt -n -v foo.txt2:C# bash4:go scala grep -r 之前介绍的grep命令都是对某一特定文本进行过滤，如果想对某一目录下的所有文件都进行过滤，那么可以用此命令。 123456➜ ls unixfoo.txt reg.txt➜ grep 'java' -r -n unixunix/foo.txt:1:java pythonunix/foo.txt:5:javascriptunix/reg.txt:1:java grep -L 过滤文件内容不符合特定pattern的所有文件名称，可与-r命令一起使用 grep -l 过滤文件内容符合特定pattern的所有文件名称，可以-r命令一起使用 123456➜ ls unixfoo.txt reg.txt➜ grep -Lr 'javascript' unixunix/reg.txt➜ grep -lr 'javascript' unixunix/foo.txt grep -w 过滤精确匹配整行的结果，如果未精确匹配，则过滤结果为空 12345678910➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep -w 'java python' foo.txtjava python➜ grep -w 'java pytho' foo.txt&lt;empty result&gt; grep -c 统计过滤的行数，注意是行哦 12345678➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep 'java' -c foo.txt2 总结看了上面的介绍，是不是对grep有了一定的了解呢？赶紧动手试试吧～]]></content>
      <tags>
        <tag>linux</tag>
        <tag>grep</tag>
      </tags>
  </entry>
</search>
