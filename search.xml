<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JSON基本操作]]></title>
    <url>%2F2019%2F05%2F13%2FJSON%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[本文记录一些日常工作中关于Jackson核心API的使用，包括JsonNode的创建及解析、与HashMap的转换、如何从String中构造JsonNode、以及ArrayNode中元素的去重等等 JSON的两种形式分为两种形式JsonArray和JsonObject，其内部可以相互循环嵌套 JsonArray: [{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: &quot;10&quot;}, {&quot;name&quot;: &quot;Jim&quot;, &quot;age&quot;: &quot;12&quot;}] 最外面为中括号[]，内部可以为多个JsonObject JsonObject: {&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;, &quot;hobbies&quot;: [&quot;basketball&quot;, &quot;tennis&quot;, &quot;football&quot;]} 最外面为大括号{}，内部为key-value形式，value依然可以嵌套array和object 创建ArrayNode及ObjectNode 创建ArrayNode 1private static final ArrayNode arrayNode = new ObjectMapper().createArrayNode(); 创建ObjectNode 1private static final ObjectNode objectNode = new ObjectMapper().createObjectNode(); 创建JsonNode(ArrayNode和ObjectNode的基类) 1private static final JsonNode jsonNode = new ObjectMapper().create...Node(); //向上转型 HashMap与JsonNode的转换 HashMap初始化 12map.put("name", "leon");map.put("age", "10"); 转换为JsonNode 12JsonNode jsonNode = new ObejctMapper().convertValue(map, JsonNode.class);实际结果形式为: &#123;"name": "leon", "age": "10"&#125; 实际转换结果是ObjectNode，而不是ArrayNode 如果要将其转换为如下形式：[{&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;}]，即ArrayNode形式，那么采用如下做法： 12ArrayNode arrayNode = new ObjectMapper().createArrayNode();arrayNode.add(jsonNode); // 将step-2中的结果添加到ArrayNode中 从String中构造JsonNode12345String jsonStr = "&#123;\n" + "\"name\": \"leon\",\n" + "\"age\": \"10\"\n" + "&#125;";JsonNode jsonNode = new ObjectMapper().readTree(jsonStr); // 注意异常处理 JsonNode的解析 ObjectNode的解析 12// 对于jsonStr, &#123;"name": "leon", "age": "10"&#125;objectNode.get("name"); // result: leon ArrayNode的解析 1234567// 对于jsonStr, [&#123;"name": "leon", "age": "10"&#125;]ArrayNode nodes = (ArrayNode)jsonNode;for (JsonNode node : nodes) &#123; node.get("name").asText(); node.get("age").asText();&#125;或者使用下标遍历 ArrayNode中元素的去重 考虑jsonStr: [{&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;}, {&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;}, {&quot;name&quot;: &quot;Jim&quot;, &quot;age&quot;: :11}] 将jsonStr转换为ArrayNode 12JsonNode jsonNode = new ObjectMapper().readTree(jsonStr);ArrayNode arrayNode = (ArrayNode) jsonNode; 将其中的value对转换为tuple，以Set方式存储 此代码用到了java tuples，java tuples - github 12345678910111213141516171819202122232425public static Set&lt;Pair&lt;String, String&gt;&gt; removeDuplicatedItems(JsonNode node) &#123; Set&lt;Pair&lt;String, String&gt;&gt; set = new LinkedHashSet&lt;&gt;(); if (!node.isArray()) &#123; return set; &#125; ArrayNode identity = (ArrayNode) node; for (JsonNode each : identity) &#123; if (!each.isObject()) &#123; continue; &#125; try &#123; String name = each.get("name").asText(); String age = each.get("age").asText(); if (StringUtils.isEmpty(name) || StringUtils.isEmpty(age)) &#123; continue; &#125; set.add(Pair.with(name, age)); &#125; catch (RuntimeException ex) &#123; // OK continue; &#125; &#125; return set; &#125; 实际上结果已经去重 对于去重后的结果进行处理，构造JsonNode(实际为ArrayNode) 123456789// pairs为去重后的数对ArrayNode result = Tools.globalMapper.createArrayNode();for (Pair&lt;String, String&gt; p : pairs) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("name", p.getValue0()); map.put("age", p.getValue1()); result.add(new ObjectMapper().convertValue(map, JsonNode.class));&#125;return result; 总结以上对于java中使用Jackson构造及解析json进行了简单介绍，当然如果你使用Groovy的话，那么它自带了Groovy.json库，使用new JsonSlurper().parseText(&quot;&quot;)、JsonOutput.toJson(&quot;&quot;)等可以很方便的构造及解析json。]]></content>
      <tags>
        <tag>json</tag>
        <tag>jackson</tag>
        <tag>jsonnode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grep命令初探]]></title>
    <url>%2F2019%2F05%2F02%2Fgrep%E5%91%BD%E4%BB%A4%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[什么是grep对于在线上服务器排查错误，学会分析log就变得异常重要，grep命令具有非常强大的文本过滤能力，是一个很好的日志过滤工具。 首先需要注意的是， grep命令是按行过滤日志的，格式为grep [options] pattern file，options支持像-A，-B，-e，-E，-f，-i，-n，-v，-r等，pattern支持常见的正则匹配，以下对其进行详细介绍。 grep参数解析 grep -A 显示目标行及之后(after)的n行，如果有多个匹配结果，则以--分割 以foo.txt为例 12345678910➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep 'java' foo.txtjava pythonjavascript 过滤foo.txt中含有&#39;java&#39;的所在行及其之后的2行数据 123456➜ grep -A 2 'java' foo.txtjava pythonC# bashgroovy--javascript grep -B 显示目标行及之前(before)的n行，如果有多个匹配结果，则以--分割 123456➜ grep -B 2 'java' foo.txtjava python--groovygo scalajavascript grep -i 匹配时不分大小写 12➜ grep -i 'c#' foo.txtC# bash grep -e 可以利用多个条件进行或匹配 123➜ grep -e 'go' -e 'bash' foo.txtC# bashgo scala grep -E 可以看作是grep -e的简单版，对多个条件进行或匹配，直接以|分隔 123➜ grep -E 'go|bash' foo.txtC# bashgo scala 如果要使用grep命令进行与操作，那么可以利用正则，以下匹配同时含有&#39;go&#39;和&#39;scala&#39;的行 12➜ grep 'go.*scala' foo.txtgo scala grep -f grep -f reg.txt foo.txt为以reg.txt定义的规则过滤foo.txt里的内容 1234567➜ cat reg.txtjavagr.*vy➜ grep -f reg.txt foo.txtjava pythongroovyjavascript grep -n 显示过滤行的行数 1234567891011➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep -f reg.txt -n foo.txt1:java python3:groovy5:javascript grep -v 显示未匹配到的行。以下显示未匹配到的行，并显示行号 123➜ grep -f reg.txt -n -v foo.txt2:C# bash4:go scala grep -r 之前介绍的grep命令都是对某一特定文本进行过滤，如果想对某一目录下的所有文件都进行过滤，那么可以用此命令。 123456➜ ls unixfoo.txt reg.txt➜ grep 'java' -r -n unixunix/foo.txt:1:java pythonunix/foo.txt:5:javascriptunix/reg.txt:1:java grep -L 过滤文件内容不符合特定pattern的所有文件名称，可与-r命令一起使用 grep -l 过滤文件内容符合特定pattern的所有文件名称，可以-r命令一起使用 123456➜ ls unixfoo.txt reg.txt➜ grep -Lr 'javascript' unixunix/reg.txt➜ grep -lr 'javascript' unixunix/foo.txt grep -w 过滤精确匹配整行的结果，如果未精确匹配，则过滤结果为空 12345678910➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep -w 'java python' foo.txtjava python➜ grep -w 'java pytho' foo.txt&lt;empty result&gt; grep -c 统计过滤的行数，注意是行哦 12345678➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep 'java' -c foo.txt2 总结看了上面的介绍，是不是对grep有了一定的了解呢？赶紧动手试试吧～]]></content>
      <tags>
        <tag>linux</tag>
        <tag>grep</tag>
      </tags>
  </entry>
</search>
