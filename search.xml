<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分布式配置中心Apollo搭建简单教程]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83Apollo%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Apollo（阿波罗）是携程开源的分布式配置中心，主要用于解决多环境配置参数紊乱的问题，能够集中化管理不同应用环境、不同集群的相关配置参数。以下介绍单机器使用不同端口去模拟DEV、UAT、PRO三套环境的详细步骤。 这里简述一下主要流程： 先在github上下载ctripcorp/apollo的master分支代码 使用scripts/docker-quick-start/sql/目录下的apolloconfigdb.sql和apolloportaldb.sql脚本建立4个数据库，分别如下： Apollo-portal: apolloportaldb Apollo-config/admin: apolloconfigdb_dev, apolloconfigdb_uat, apolloconfigdb_pro 注意使用apolloconfigdb.sql建立数据库时，需要改下数据库名称，分别对应DEV，UAT，PRO环境 修改scripts/build.sh脚本，更改结果如下: 12345678910111213141516#!/bin/sh# apollo config db infoapollo_config_db_url=jdbc:mysql://localhost:3306/apolloconfigdb?characterEncoding=utf8apollo_config_db_username=rootapollo_config_db_password=root# apollo portal db infoapollo_portal_db_url=jdbc:mysql://localhost:3306/apolloportaldb?characterEncoding=utf8apollo_portal_db_username=rootapollo_portal_db_password=root# meta server url, different environments should have different meta server addressesdev_meta=http://localhost:8080uat_meta=http://localhost:8180pro_meta=http://localhost:8280 这里的apolloconfigdb名字暂时先这样写，之后打包结束后会进行更改。端口设置如下：portalService端口为8070；dev环境：configService端口为8080，adminService端口为8090；uat环境：configService端口为8180，adminService端口为8190；pro环境：configService端口为8280，adminService端口为8290。 修改数据库 将apolloportaldb数据库中的serverconfig表中的apollo.portal.envs的值改为dev,uat,pro，以逗号隔离 将apolloconfigdb_dev数据库的serverconfig表中的eureka.service.url的value改为http://localhost:8080/eureka/ 将apolloconfigdb_uat数据库的serverconfig表中的eureka.service.url的value改为http://localhost:8180/eureka/ 将apolloconfigdb_pro数据库的serverconfig表中的eureka.service.url的value改为http://localhost:8280/eureka/ 编译项目, 运行sh scripts/build.sh 将上一步apollo-portal/target, apollo-adminservice/target, apollo-configservice/target得到的zip包进行归类，目录结构可参考如下： 1234567891011121314151617181920212223242526deploy-apollo├── apollo-portal-1.5.0-SNAPSHOT-github│ ├── apollo-portal-1.5.0-SNAPSHOT-sources.jar│ ├── apollo-portal-1.5.0-SNAPSHOT.jar│ ├── apollo-portal.conf│ ├── apollo-portal.jar│ ├── config│ └── scripts├── apollo-portal-1.5.0-SNAPSHOT-github.zip├── dev│ ├── apollo-adminservice-1.5.0-SNAPSHOT-github│ ├── apollo-adminservice-1.5.0-SNAPSHOT-github.zip│ ├── apollo-configservice-1.5.0-SNAPSHOT-github│ └── apollo-configservice-1.5.0-SNAPSHOT-github.zip├── pro│ ├── apollo-adminservice-1.5.0-SNAPSHOT-github│ ├── apollo-adminservice-1.5.0-SNAPSHOT-github.zip│ ├── apollo-configservice-1.5.0-SNAPSHOT-github│ └── apollo-configservice-1.5.0-SNAPSHOT-github.zip├── start.sh├── stop.sh└── uat ├── apollo-adminservice-1.5.0-SNAPSHOT-github ├── apollo-adminservice-1.5.0-SNAPSHOT-github.zip ├── apollo-configservice-1.5.0-SNAPSHOT-github └── apollo-configservice-1.5.0-SNAPSHOT-github.zip 其中，start.sh和stop.sh脚本为自己的准备，稍后介绍。 修改dev目录下apollo-adminservice-1.5.0-SNAPSHOT-github/config/application-github.properties中的数据库，对应为apolloconfigdb_dev，修改apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/startup.sh下的端口，具体为SERVER_PORT=8090；apollo-configservice-1.5.0-SNAPSHOT-github/config/application-github.properties中的数据库，对应为apolloconfigdb_dev，修改apollo-configservice-1.5.0-SNAPSHOT-github/scripts/startup.sh下的端口，具体为SERVER_PORT=8080 uat,pro目录下的数据和端口分为作相似的修改(db_uat, 8180, 8190; db_pro, 8280, 8290) 运行sh start.sh和sh stop.sh基本进行项目的启动和关闭 12345678910111213141516171819# start.sh#!/bin/bash# 每个环境需要先启动configservice，后启动adminservice）echo "启动DEV环境apollo服务..."sh dev/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/startup.shsh dev/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/startup.shecho "启UAT环境apollo服务..."sh uat/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/startup.shsh uat/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/startup.shecho "启动PRO环境apollo服务..."sh pro/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/startup.shsh pro/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/startup.shecho "启动apollo的portal服务..."sh apollo-portal-1.5.0-SNAPSHOT-github/scripts/startup.sh 123456789101112131415161718# stop.sh#!/bin/bashecho "关闭DEV环境apollo服务..."sh dev/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shsh dev/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shecho "关闭UAT环境apollo服务..."sh uat/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shsh uat/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shecho "关闭PRO环境apollo服务..."sh pro/apollo-configservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shsh pro/apollo-adminservice-1.5.0-SNAPSHOT-github/scripts/shutdown.shecho "关闭apollo的portal服务..."sh apollo-portal-1.5.0-SNAPSHOT-github/scripts/shutdown.sh 访问apollo控制界面 启动服务后，访问localhost:8070，默认用户名为apollo，密码为admin 注意事项，写在最后 如果启动服务时，发现报错，根据错误提示查看/opt/logs目录下的日志]]></content>
      <tags>
        <tag>apollo</tag>
        <tag>配置中心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON基本操作]]></title>
    <url>%2F2019%2F05%2F13%2FJSON%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[本文记录一些日常工作中关于Jackson核心API的使用，包括JsonNode的创建及解析、与HashMap的转换、如何从String中构造JsonNode、以及ArrayNode中元素的去重等等 JSON的两种形式分为两种形式JsonArray和JsonObject，其内部可以相互循环嵌套 JsonArray: [{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: &quot;10&quot;}, {&quot;name&quot;: &quot;Jim&quot;, &quot;age&quot;: &quot;12&quot;}] 最外面为中括号[]，内部可以为多个JsonObject JsonObject: {&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;, &quot;hobbies&quot;: [&quot;basketball&quot;, &quot;tennis&quot;, &quot;football&quot;]} 最外面为大括号{}，内部为key-value形式，value依然可以嵌套array和object 创建ArrayNode及ObjectNode 创建ArrayNode 1private static final ArrayNode arrayNode = new ObjectMapper().createArrayNode(); 创建ObjectNode 1private static final ObjectNode objectNode = new ObjectMapper().createObjectNode(); 创建JsonNode(ArrayNode和ObjectNode的基类) 1private static final JsonNode jsonNode = new ObjectMapper().create...Node(); //向上转型 HashMap与JsonNode的转换 HashMap初始化 12map.put("name", "leon");map.put("age", "10"); 转换为JsonNode 12JsonNode jsonNode = new ObejctMapper().convertValue(map, JsonNode.class);实际结果形式为: &#123;"name": "leon", "age": "10"&#125; 实际转换结果是ObjectNode，而不是ArrayNode 如果要将其转换为如下形式：[{&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;}]，即ArrayNode形式，那么采用如下做法： 12ArrayNode arrayNode = new ObjectMapper().createArrayNode();arrayNode.add(jsonNode); // 将step-2中的结果添加到ArrayNode中 从String中构造JsonNode12345String jsonStr = "&#123;\n" + "\"name\": \"leon\",\n" + "\"age\": \"10\"\n" + "&#125;";JsonNode jsonNode = new ObjectMapper().readTree(jsonStr); // 注意异常处理 JsonNode的解析 ObjectNode的解析 12// 对于jsonStr, &#123;"name": "leon", "age": "10"&#125;objectNode.get("name"); // result: leon ArrayNode的解析 1234567// 对于jsonStr, [&#123;"name": "leon", "age": "10"&#125;]ArrayNode nodes = (ArrayNode)jsonNode;for (JsonNode node : nodes) &#123; node.get("name").asText(); node.get("age").asText();&#125;或者使用下标遍历 ArrayNode中元素的去重 考虑jsonStr: [{&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;}, {&quot;name&quot;: &quot;leon&quot;, &quot;age&quot;: &quot;10&quot;}, {&quot;name&quot;: &quot;Jim&quot;, &quot;age&quot;: :11}] 将jsonStr转换为ArrayNode 12JsonNode jsonNode = new ObjectMapper().readTree(jsonStr);ArrayNode arrayNode = (ArrayNode) jsonNode; 将其中的value对转换为tuple，以Set方式存储 此代码用到了java tuples，java tuples - github 12345678910111213141516171819202122232425public static Set&lt;Pair&lt;String, String&gt;&gt; removeDuplicatedItems(JsonNode node) &#123; Set&lt;Pair&lt;String, String&gt;&gt; set = new LinkedHashSet&lt;&gt;(); if (!node.isArray()) &#123; return set; &#125; ArrayNode identity = (ArrayNode) node; for (JsonNode each : identity) &#123; if (!each.isObject()) &#123; continue; &#125; try &#123; String name = each.get("name").asText(); String age = each.get("age").asText(); if (StringUtils.isEmpty(name) || StringUtils.isEmpty(age)) &#123; continue; &#125; set.add(Pair.with(name, age)); &#125; catch (RuntimeException ex) &#123; // OK continue; &#125; &#125; return set; &#125; 实际上结果已经去重 对于去重后的结果进行处理，构造JsonNode(实际为ArrayNode) 123456789// pairs为去重后的数对ArrayNode result = Tools.globalMapper.createArrayNode();for (Pair&lt;String, String&gt; p : pairs) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("name", p.getValue0()); map.put("age", p.getValue1()); result.add(new ObjectMapper().convertValue(map, JsonNode.class));&#125;return result; 总结以上对于java中使用Jackson构造及解析json进行了简单介绍，当然如果你使用Groovy的话，那么它自带了Groovy.json库，使用new JsonSlurper().parseText(&quot;&quot;)、JsonOutput.toJson(&quot;&quot;)等可以很方便的构造及解析json。]]></content>
      <tags>
        <tag>json</tag>
        <tag>jackson</tag>
        <tag>jsonnode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grep命令初探]]></title>
    <url>%2F2019%2F05%2F02%2Fgrep%E5%91%BD%E4%BB%A4%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[什么是grep对于在线上服务器排查错误，学会分析log就变得异常重要，grep命令具有非常强大的文本过滤能力，是一个很好的日志过滤工具。 首先需要注意的是， grep命令是按行过滤日志的，格式为grep [options] pattern file，options支持像-A，-B，-e，-E，-f，-i，-n，-v，-r等，pattern支持常见的正则匹配，以下对其进行详细介绍。 grep参数解析 grep -A 显示目标行及之后(after)的n行，如果有多个匹配结果，则以--分割 以foo.txt为例 12345678910➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep 'java' foo.txtjava pythonjavascript 过滤foo.txt中含有&#39;java&#39;的所在行及其之后的2行数据 123456➜ grep -A 2 'java' foo.txtjava pythonC# bashgroovy--javascript grep -B 显示目标行及之前(before)的n行，如果有多个匹配结果，则以--分割 123456➜ grep -B 2 'java' foo.txtjava python--groovygo scalajavascript grep -i 匹配时不分大小写 12➜ grep -i 'c#' foo.txtC# bash grep -e 可以利用多个条件进行或匹配 123➜ grep -e 'go' -e 'bash' foo.txtC# bashgo scala grep -E 可以看作是grep -e的简单版，对多个条件进行或匹配，直接以|分隔 123➜ grep -E 'go|bash' foo.txtC# bashgo scala 如果要使用grep命令进行与操作，那么可以利用正则，以下匹配同时含有&#39;go&#39;和&#39;scala&#39;的行 12➜ grep 'go.*scala' foo.txtgo scala grep -f grep -f reg.txt foo.txt为以reg.txt定义的规则过滤foo.txt里的内容 1234567➜ cat reg.txtjavagr.*vy➜ grep -f reg.txt foo.txtjava pythongroovyjavascript grep -n 显示过滤行的行数 1234567891011➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep -f reg.txt -n foo.txt1:java python3:groovy5:javascript grep -v 显示未匹配到的行。以下显示未匹配到的行，并显示行号 123➜ grep -f reg.txt -n -v foo.txt2:C# bash4:go scala grep -r 之前介绍的grep命令都是对某一特定文本进行过滤，如果想对某一目录下的所有文件都进行过滤，那么可以用此命令。 123456➜ ls unixfoo.txt reg.txt➜ grep 'java' -r -n unixunix/foo.txt:1:java pythonunix/foo.txt:5:javascriptunix/reg.txt:1:java grep -L 过滤文件内容不符合特定pattern的所有文件名称，可与-r命令一起使用 grep -l 过滤文件内容符合特定pattern的所有文件名称，可以-r命令一起使用 123456➜ ls unixfoo.txt reg.txt➜ grep -Lr 'javascript' unixunix/reg.txt➜ grep -lr 'javascript' unixunix/foo.txt grep -w 过滤精确匹配整行的结果，如果未精确匹配，则过滤结果为空 12345678910➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep -w 'java python' foo.txtjava python➜ grep -w 'java pytho' foo.txt&lt;empty result&gt; grep -c 统计过滤的行数，注意是行哦 12345678➜ cat foo.txtjava pythonC# bashgroovygo scalajavascript➜ grep 'java' -c foo.txt2 总结看了上面的介绍，是不是对grep有了一定的了解呢？赶紧动手试试吧～]]></content>
      <tags>
        <tag>linux</tag>
        <tag>grep</tag>
      </tags>
  </entry>
</search>
